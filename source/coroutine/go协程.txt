go协程生命周期：
schedule() => execute() => gogo() => 业务方法 => goexit()


触发切换：
为何需要触发切换？
按照 go协程生命周期 ，则会导致协程饥饿，导致一直执行耗时长的协程，其他协程不能得到调度；

切换时机：
1.线程执行中间，会挂起当前协程，执行其他协程（参照抢占式调度）；
2.业务方法内调用gopark方法，主动挂起，调用的协程会重回schedule()；
    何时调用gopark？ 例如time.Sleep()
3.系统调用完成时，调用的协程会重回schedule()；


runtime.morestack() 检查协程栈是否有足够的空间

基于协作的抢占式调度：
1.标记抢占，每次执行runtime.morestack()，都会判断是否被抢占，如果被抢占，则重回schedule()；
2.执行超过20毫秒会被标记抢占；

基于信号的抢占式调度：
1.注册SIGURG信号处理函数；
2.GC工作时，向目标线程发送信号；
3.线程收到信号，触发doSigPreempt()函数调度；
